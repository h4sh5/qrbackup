<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>QRbackup</title>
<style>
  * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

  body{font-family:system-ui, sans-serif; margin:2rem}
  button{margin-top:1rem}
  #log{white-space:pre-wrap; font-size:.8rem; background:#f6f6f6; padding:.5rem; max-height:12rem; overflow:auto}

/*  for printing onto a4 pages*/
 .page {
    width: 210mm;
    height: 297mm;
    background: white;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
    margin: 0 auto 0px auto;
    padding: 1mm;
    display: flex;
    flex-direction: column;
}

.page-note {
    height: 1mm;
    display: inline;
    align-items: center;
    justify-content: left;
    font-size: 6px;
    padding: 0;
    margin-top: 0;
    color: #333;
    margin-bottom: 0;
    margin-top: -4px;
    margin-left: 96%;
}

.page-content {
    flex: 1;
    display: flex;
    flex-wrap: wrap;
    align-content: flex-start;
    gap: 0mm;
}

.image-container {
    width: calc((100% - 12mm) / 4);
/*    height: calc((100% - 25mm) / 6);*/
    background: #f0f0f0;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 0;
    box-sizing: unset;
}


@media print {
    body {
        background: white;
        padding: 0;
        margin: 0;
    }

    .controls {
        display: none;
    }

    .page {
        width: 210mm;
        height: 297mm;
        box-shadow: none;
        margin: 0;
        page-break-after: always;
    }

    .page:last-child {
        page-break-after: avoid;
    }
}

@media screen and (max-width: 768px) {
    .page {
        width: 100%;
        max-width: 210mm;
        height: auto;
        min-height: 297mm;
    }
}

</style>
</head>
<body>

<section class="removeBeforePrint">

<h1>QRBackup</h1>
<p style="color:#bbb">*WebAssembly used, no server side processing. Files are not uploaded to any servers, preserving your privacy.</p>
<p>Backup any file with printable paper copies using QR codes. For best results when restoring, scan in color with high resolution (600dpi+). Each QR code contains a preamble of which chunk it is (for example "9/10:", followed by <a target=_blank href=https://datatracker.ietf.org/doc/rfc9285/>base45</a> encoded data of the chunk.)</p>

<p><a href='./restore.html'>Use this page to restore</a>.</p>

<p>Potential use cases include long term data archiving against digital obsolescence, embedding an ebook at the back of a paperback book, of sending arbitrary files over mail, legal notarizing, putting files in paper zines, etc.</p>

<form>
<input type="file" id="fileInput">
<button id="runBtn" disabled>Run</button>
<nbsp>

<input type="button" value="Print" onClick="window.print()">
<input type="reset" onClick="window.location.reload();">
</span>

<div id="log">Log (open console for more): <br></div>

</section>

<div id="pagesContainer"></div>


<script>
const log = (...args) => {
  const box = document.getElementById('log');
  box.textContent += args.join(' ') + '\n';
  box.scrollTop = box.scrollHeight;
};
const downloadBlob = (blob, name) => {
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = name;
  a.click();
  URL.revokeObjectURL(a.href);
};

function divmod(a,b) {
    var remainder = a
    var quotient = 0
    if (a >= b) {
        remainder = a % b
  quotient = (a - remainder) / b
    }
    return [ quotient, remainder ]
  }


// ----------- base45 -------------------

const BASE45_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
function fromCharCode(c) {
  return BASE45_CHARSET.charAt(c);
};


function b45encode(uint8array) {
  var output = [];

  for (var i = 0, length = uint8array.length; i < length; i+=2) {
    if (uint8array.length -i > 1) {
       var x = (uint8array[i]<<8)+ uint8array[i+1]
       var [ e, x ]  = divmod(x, 45*45)
       var [ d, c ] = divmod(x, 45)
       output.push(fromCharCode(c) + fromCharCode(d) + fromCharCode(e))
   } else {
       var x = uint8array[i]
       var [ d, c ] = divmod(x, 45)
       output.push(fromCharCode(c) + fromCharCode(d))
   }
  }
  return output.join('')
};


</script>

  
<script type="module">

// qrinit can be called whatever
import qrinit, {qr_svg, SvgOptions, Shape, ECL, Version} from './pkg/fast_qr.js';
await qrinit();

async function encodeFileToQRs (file) {
  const _B45CHARSPERBYTE = 1.5; // log45(256) is around 1.45, round up
  const QR_ALPHANUMERICMODE_MAX = 4296; // max alphanumeric chars per V40 QR code
  const raw = new Uint8Array(await file.arrayBuffer());
  // calculate approx number of raw chunks
  const estNumChunks = Math.ceil(raw.length / (QR_ALPHANUMERICMODE_MAX/_B45CHARSPERBYTE));
  log(`estimated number of chunks: ${estNumChunks}`);
  // use that to generate the preamble size (preamble being the data marking which segment it is followed by '/' then total number of segments and then ':' e.g. 1/20: 12/20: etc. at the start of each chunk)
  // the symbols in the preamble are intentionally part of the base45 scheme for efficient QR alphanumeric encoding
  const preambleLength = estNumChunks.toString().length * 2 + 2; // so that the numchunks can be at most in there twice, followed by the two symbols, such as when there are 500 maximum chunks, the last chunk will have preamble 500/500:
  log(`preambleLength: ${preambleLength}`)
  let maxDataPerQR = QR_ALPHANUMERICMODE_MAX - preambleLength;
  log("max data per QR:",maxDataPerQR);
  // number of chunks divided by max size of qr code data encoding
  const chunkSize = Math.floor(maxDataPerQR/_B45CHARSPERBYTE);
  // log(``)
  console.log(`each chunk about ${chunkSize}`);
  const chunks = [];
  const images = [];
  for (let i = 0; i < raw.length; i += chunkSize) {
    chunks.push(raw.slice(i, i + chunkSize));
  }
  log(`Hang on.. (processing ${chunks.length} chunks)`);

  let counter = 1;
  let failed = 0;
  const total = chunks.length;

  

  /* inner functions for generate QR code page spreads */
  let currentPage = null;
  let currentContent = null;
  let pageIndex = 1;
  let imageCount = 0;
  const QRCODES_PER_PAGE = 24;

  function createNewPage(totalCount) {
            const page = document.createElement('div');
            page.className = 'page';

            const pagenote = document.createElement('div');
            pagenote.className = 'page-note';
            pagenote.textContent = `${file.name} ${pageIndex}/${totalCount}`;

            const content = document.createElement('div');
            content.className = 'page-content';

            page.appendChild(pagenote);
            page.appendChild(content);
            

            document.getElementById('pagesContainer').appendChild(page);
            const hline = document.createElement('hr');
            hline.className = 'removeBeforePrint';
            document.getElementById('pagesContainer').appendChild(hline);

            currentPage = page;
            currentContent = content;
            imageCount = 0;

            pageIndex++;
        }

  function addImage(svgInnerHTML, totalCount) {
      if (!currentContent || imageCount >= QRCODES_PER_PAGE) {
          createNewPage(totalCount);
      }
      const imageContainer = document.createElement('div');
      imageContainer.className = 'image-container';

      imageContainer.innerHTML = svgInnerHTML;
      currentContent.appendChild(imageContainer);

      imageCount++;
    }
  /****************************************************/

  for (const chunk of chunks) {
    const opts = new SvgOptions()
      .shape(Shape.Square)
      .background_color('#ffffff')
      .module_color('#000000')
      .version(Version.V40) // max size
      .ecl(ECL.L); // 7% error correct, most amount of data fit

    // const b45 = encodeBase45(chunk); // base45 is most efficient for QR codes
    const b45 = b45encode(chunk);
    let preamble = `${counter}/${chunks.length}:`; // to mark which chunk it is for decoding
    console.log(`${counter} chunk (size ${chunk.length})`);
    console.log(`${counter} b45 (size ${b45.length})`);
    const svg_qr_code = qr_svg(preamble + b45, opts);
    // console.log("svg:", svg);
    if (svg_qr_code == undefined) {
      failed += 1;
      log(`chunk ${counter}: SVG failed to generate`);
    }
    images.push(svg_qr_code);
    counter++;
  }

  const pageCount =  Math.ceil(images.length/QRCODES_PER_PAGE);
  for (var i = 0; i < images.length; i++) {
    console.log(images[i]);
    addImage(images[i], Math.ceil(images.length/QRCODES_PER_PAGE));
  }

  log(`generated ${images.length} QR codes across ${pageCount} pages`);

}

window.encodeFileToQRs = encodeFileToQRs;

</script>

<script>

window.onbeforeprint = (event) => {
  // hide elements that are not the generated pages before print
  let elementsToHide = document.getElementsByClassName("removeBeforePrint");
  for (let i = 0; i < elementsToHide.length; i++) {
    elementsToHide[i].style.display = 'none';
  }
}

const fileInput = document.getElementById('fileInput');
const runBtn    = document.getElementById('runBtn');

runBtn.disabled = !fileInput.files.length;

fileInput.addEventListener('change', () => {
  runBtn.disabled = !fileInput.files.length;
});


runBtn.addEventListener('click', async () => {
  runBtn.disabled = true;
  log('\nStarting... (please refresh the page before encoding another file)');

  const file = fileInput.files[0];
  await window.encodeFileToQRs(file);
  console.log("finished");
  runBtn.disabled = false;
});

</script>
</body>
</html>
