<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>QRbackup restore</title>
<style>
  * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

  body{font-family:system-ui, sans-serif; margin:2rem}
  button{margin-top:1rem}
  #log{white-space:pre-wrap; font-size:.8rem; background:#f6f6f6; padding:.5rem; max-height:12rem; overflow:auto}

/*  for printing onto a4 pages*/
 .page {
    width: 210mm;
    height: 297mm;
    background: white;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
    margin: 0 auto 0px auto;
    padding: 1mm;
    display: flex;
    flex-direction: column;
}

.page-note {
    height: 1mm;
    display: inline;
    align-items: center;
    justify-content: left;
    font-size: 6px;
    padding: 0;
    margin-top: 0;
    color: #333;
    margin-bottom: 0;
    margin-top: -4px;
    margin-left: 96%;
}

.page-content {
    flex: 1;
    display: flex;
    flex-wrap: wrap;
    align-content: flex-start;
    gap: 0mm;
}

.image-container {
    width: calc((100% - 12mm) / 4);
/*    height: calc((100% - 25mm) / 6);*/
    background: #f0f0f0;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 0;
    box-sizing: unset;
}


@media print {
    body {
        background: white;
        padding: 0;
        margin: 0;
    }

    .controls {
        display: none;
    }

    .page {
        width: 210mm;
        height: 297mm;
        box-shadow: none;
        margin: 0;
        page-break-after: always;
    }

    .page:last-child {
        page-break-after: avoid;
    }
}

@media screen and (max-width: 768px) {
    .page {
        width: 100%;
        max-width: 210mm;
        height: auto;
        min-height: 297mm;
    }
}

</style>
</head>
<body>

<section class="removeBeforePrint">

<h1>QRBackup restore</h1>
<p style="color:#bbb">*WebAssembly used, no server side processing. Files are not uploaded to any servers, preserving your privacy.</p>
<p>Restore any scanned images with QR codes generated by <a href=./index.html>QRBackup</a>. For best results when restoring, scan in color with high resolution (600dpi+). Each QR code contains a preamble of which chunk it is (for example "9/10:", followed by <a target=_blank href=https://datatracker.ietf.org/doc/rfc9285/>base45</a> encoded data of the chunk.)</p>


<form>
<input type="file" id="fileInput" multiple>
<button id="runBtn" disabled>Restore</button>
<nbsp>

<span>filename to save as: <input id=prefixoverride placeholder="restored.bin" value="restored.bin"></span>
<input type="reset" onClick="window.location.reload();">
</span>

<div id="log">Log (open console for more): <br></div>

</section>

<div id="pagesContainer"></div>


<script>
const log = (...args) => {
  const box = document.getElementById('log');
  box.textContent += args.join(' ') + '\n';
  box.scrollTop = box.scrollHeight;
};
const downloadBlob = (blob, name) => {
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = name;
  a.click();
  URL.revokeObjectURL(a.href);
};

// ----------- base45 -------------------

const BASE45_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
function fromCharCode(c) {
  return BASE45_CHARSET.charAt(c);
}

function divmod(a,b) {
    var remainder = a
    var quotient = 0
    if (a >= b) {
        remainder = a % b
  quotient = (a - remainder) / b
    }
    return [ quotient, remainder ]
  }


function b45decode(str) {
  var output = []
  var buf = []

  for(var i = 0, length=str.length; i < length; i++) {
     var j = BASE45_CHARSET.indexOf(str[i])
     if (j < 0)
            throw new Error('Base45 decode: unknown character');
     buf.push(j)
  }

  for(var i = 0, length=buf.length; i < length; i+=3) {
     var x = buf[i] + buf[i + 1] * 45
     if (length - i >= 3) {
        var [d, c] = divmod(x + buf[i + 2] * 45 * 45,256)
        output.push(d)
        output.push(c)
     } else {
       output.push(x)
     }
  }
  return new Uint8Array(output);
};



</script>

<script src='./pkg/zbar-wasm.js'></script>

<script>

window.onbeforeprint = (event) => {
  // hide elements that are not the generated pages before print
  let elementsToHide = document.getElementsByClassName("removeBeforePrint");
  for (let i = 0; i < elementsToHide.length; i++) {
    elementsToHide[i].style.display = 'none';
  }
}

const fileInput = document.getElementById('fileInput');
const runBtn    = document.getElementById('runBtn');

runBtn.disabled = !fileInput.files.length;

fileInput.addEventListener('change', () => {
  runBtn.disabled = !fileInput.files.length;
});

runBtn.addEventListener('click', async () => {
  runBtn.disabled = true;
  log('\nStarting...');
  
  let files = fileInput.files;
  var currentPart;
  var totalParsed = 0;
  let dataChunksByIndex = {}; // <int:Uint8Array>
  for (var i = 0 ; i < files.length; i++) {
        log('reading file:', files[i].name);
        const fileArrayBuffer = await files[i].arrayBuffer();
        const fileUint8Array = new Uint8Array(fileArrayBuffer);
        var tempImage = document.createElement('img');
        tempImage.src = 'data:image/png;base64, ' + fileUint8Array.toBase64();
        document.body.appendChild(tempImage);
        await tempImage.decode();
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = tempImage.naturalWidth;
        canvas.height = tempImage.naturalHeight;
        context.drawImage(tempImage, 0, 0);
        
        console.log(`width: ${canvas.width} height: ${canvas.height}`);

        const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
        const results  = await zbarWasm.scanImageData(imageData);
        let parts = 0;
        for (let symbol of results) {
            decodedData = symbol.decode();
            const preamble = decodedData.split(':')[0] + ':';
            console.log('preamble:', preamble);
            parts = parseInt(preamble.split('/')[1]);
            currentPart = parseInt(preamble.split('/')[0]);
            console.log(`parsed preamble ${currentPart}/${parts}`);
            dataChunksByIndex[currentPart] = b45decode(decodedData.slice(preamble.length));
            console.log(`decodedData len: ${decodedData.length} , after slicing preamble length:${decodedData.slice(preamble.length).length}`);
            totalParsed++;
        }
        // tempImage.remove(); // remove tempImage since it's no longer needed
        log(`parsed ${totalParsed}/${parts} QR codes`);

  }

  var outData = [];
  // join all buffers together
  Object.keys(dataChunksByIndex).sort((a, b) => a - b ).reduce(
  (obj, key) => { 
    console.log(`adding to outData: ${key} (len: ${dataChunksByIndex[key].length})`);
    outData.push(...dataChunksByIndex[key]);
  }, {});
  const outBlob   = new Blob([new Uint8Array(outData)], {type:'application/octet-stream'});
  downloadBlob(outBlob, document.getElementById('prefixoverride').value);

  console.log("finished");
  runBtn.disabled = false;
});

</script>
</body>
</html>
